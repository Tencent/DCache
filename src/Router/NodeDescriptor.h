// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.1.0.
// **********************************************************************

#ifndef __NODEDESCRIPTOR_H_
#define __NODEDESCRIPTOR_H_

#include <map>
#include <string>
#include <vector>
#include "tup/Tars.h"
using namespace std;

namespace tars
{
enum ServerState
{
    Inactive,
    Activating,
    Active,
    Deactivating,
    Destroying,
    Destroyed,
};
inline string etos(const ServerState& e)
{
    switch (e)
    {
        case Inactive:
            return "Inactive";
        case Activating:
            return "Activating";
        case Active:
            return "Active";
        case Deactivating:
            return "Deactivating";
        case Destroying:
            return "Destroying";
        case Destroyed:
            return "Destroyed";
        default:
            return "";
    }
}
inline int stoe(const string& s, ServerState& e)
{
    if (s == "Inactive")
    {
        e = Inactive;
        return 0;
    }
    if (s == "Activating")
    {
        e = Activating;
        return 0;
    }
    if (s == "Active")
    {
        e = Active;
        return 0;
    }
    if (s == "Deactivating")
    {
        e = Deactivating;
        return 0;
    }
    if (s == "Destroying")
    {
        e = Destroying;
        return 0;
    }
    if (s == "Destroyed")
    {
        e = Destroyed;
        return 0;
    }

    return -1;
}

struct LoadInfo : public tars::TarsStructBase
{
public:
    static string className() { return "tars.LoadInfo"; }
    static string MD5() { return "51ba7d6564ede253c29d5a3399944a1b"; }
    LoadInfo() : avg1(0), avg5(0), avg15(0), avgCpu(0) {}
    void resetDefautlt()
    {
        avg1 = 0;
        avg5 = 0;
        avg15 = 0;
        avgCpu = 0;
    }
    template <typename WriterT>
    void writeTo(tars::TarsOutputStream<WriterT>& _os) const
    {
        _os.write(avg1, 0);
        _os.write(avg5, 1);
        _os.write(avg15, 2);
        if (avgCpu != 0)
        {
            _os.write(avgCpu, 3);
        }
    }
    template <typename ReaderT>
    void readFrom(tars::TarsInputStream<ReaderT>& _is)
    {
        resetDefautlt();
        _is.read(avg1, 0, true);
        _is.read(avg5, 1, true);
        _is.read(avg15, 2, true);
        _is.read(avgCpu, 3, false);
    }
    ostream& display(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.display(avg1, "avg1");
        _ds.display(avg5, "avg5");
        _ds.display(avg15, "avg15");
        _ds.display(avgCpu, "avgCpu");
        return _os;
    }
    ostream& displaySimple(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.displaySimple(avg1, true);
        _ds.displaySimple(avg5, true);
        _ds.displaySimple(avg15, true);
        _ds.displaySimple(avgCpu, false);
        return _os;
    }

public:
    tars::Float avg1;
    tars::Float avg5;
    tars::Float avg15;
    tars::Int32 avgCpu;
};
inline bool operator==(const LoadInfo& l, const LoadInfo& r)
{
    return l.avg1 == r.avg1 && l.avg5 == r.avg5 && l.avg15 == r.avg15 && l.avgCpu == r.avgCpu;
}
inline bool operator!=(const LoadInfo& l, const LoadInfo& r) { return !(l == r); }

struct PatchInfo : public tars::TarsStructBase
{
public:
    static string className() { return "tars.PatchInfo"; }
    static string MD5() { return "8c67e0afd48e8af5b3238a284ca8ac20"; }
    PatchInfo()
        : bPatching(false), iPercent(0), iModifyTime(0), sVersion(""), sResult(""), bSucc(false)
    {
    }
    void resetDefautlt()
    {
        bPatching = false;
        iPercent = 0;
        iModifyTime = 0;
        sVersion = "";
        sResult = "";
        bSucc = false;
    }
    template <typename WriterT>
    void writeTo(tars::TarsOutputStream<WriterT>& _os) const
    {
        _os.write(bPatching, 0);
        _os.write(iPercent, 1);
        _os.write(iModifyTime, 2);
        _os.write(sVersion, 3);
        _os.write(sResult, 4);
        if (bSucc != false)
        {
            _os.write(bSucc, 5);
        }
    }
    template <typename ReaderT>
    void readFrom(tars::TarsInputStream<ReaderT>& _is)
    {
        resetDefautlt();
        _is.read(bPatching, 0, true);
        _is.read(iPercent, 1, true);
        _is.read(iModifyTime, 2, true);
        _is.read(sVersion, 3, true);
        _is.read(sResult, 4, true);
        _is.read(bSucc, 5, false);
    }
    ostream& display(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.display(bPatching, "bPatching");
        _ds.display(iPercent, "iPercent");
        _ds.display(iModifyTime, "iModifyTime");
        _ds.display(sVersion, "sVersion");
        _ds.display(sResult, "sResult");
        _ds.display(bSucc, "bSucc");
        return _os;
    }
    ostream& displaySimple(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.displaySimple(bPatching, true);
        _ds.displaySimple(iPercent, true);
        _ds.displaySimple(iModifyTime, true);
        _ds.displaySimple(sVersion, true);
        _ds.displaySimple(sResult, true);
        _ds.displaySimple(bSucc, false);
        return _os;
    }

public:
    tars::Bool bPatching;
    tars::Int32 iPercent;
    tars::Int32 iModifyTime;
    std::string sVersion;
    std::string sResult;
    tars::Bool bSucc;
};
inline bool operator==(const PatchInfo& l, const PatchInfo& r)
{
    return l.bPatching == r.bPatching && l.iPercent == r.iPercent &&
           l.iModifyTime == r.iModifyTime && l.sVersion == r.sVersion && l.sResult == r.sResult &&
           l.bSucc == r.bSucc;
}
inline bool operator!=(const PatchInfo& l, const PatchInfo& r) { return !(l == r); }

struct PreparePatchInfo : public tars::TarsStructBase
{
public:
    static string className() { return "tars.PreparePatchInfo"; }
    static string MD5() { return "716a45598331cd036c23128ce51ae6ff"; }
    PreparePatchInfo()
        : bPreparePatching(false), iPercent(0), iModifyTime(0), sVersion(""), sResult(""), ret(0)
    {
    }
    void resetDefautlt()
    {
        bPreparePatching = false;
        iPercent = 0;
        iModifyTime = 0;
        sVersion = "";
        sResult = "";
        ret = 0;
    }
    template <typename WriterT>
    void writeTo(tars::TarsOutputStream<WriterT>& _os) const
    {
        _os.write(bPreparePatching, 0);
        _os.write(iPercent, 1);
        _os.write(iModifyTime, 2);
        _os.write(sVersion, 3);
        _os.write(sResult, 4);
        if (ret != 0)
        {
            _os.write(ret, 5);
        }
    }
    template <typename ReaderT>
    void readFrom(tars::TarsInputStream<ReaderT>& _is)
    {
        resetDefautlt();
        _is.read(bPreparePatching, 0, true);
        _is.read(iPercent, 1, true);
        _is.read(iModifyTime, 2, true);
        _is.read(sVersion, 3, true);
        _is.read(sResult, 4, true);
        _is.read(ret, 5, false);
    }
    ostream& display(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.display(bPreparePatching, "bPreparePatching");
        _ds.display(iPercent, "iPercent");
        _ds.display(iModifyTime, "iModifyTime");
        _ds.display(sVersion, "sVersion");
        _ds.display(sResult, "sResult");
        _ds.display(ret, "ret");
        return _os;
    }
    ostream& displaySimple(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.displaySimple(bPreparePatching, true);
        _ds.displaySimple(iPercent, true);
        _ds.displaySimple(iModifyTime, true);
        _ds.displaySimple(sVersion, true);
        _ds.displaySimple(sResult, true);
        _ds.displaySimple(ret, false);
        return _os;
    }

public:
    tars::Bool bPreparePatching;
    tars::Int32 iPercent;
    tars::Int32 iModifyTime;
    std::string sVersion;
    std::string sResult;
    tars::Int32 ret;
};
inline bool operator==(const PreparePatchInfo& l, const PreparePatchInfo& r)
{
    return l.bPreparePatching == r.bPreparePatching && l.iPercent == r.iPercent &&
           l.iModifyTime == r.iModifyTime && l.sVersion == r.sVersion && l.sResult == r.sResult &&
           l.ret == r.ret;
}
inline bool operator!=(const PreparePatchInfo& l, const PreparePatchInfo& r) { return !(l == r); }

struct NodeInfo : public tars::TarsStructBase
{
public:
    static string className() { return "tars.NodeInfo"; }
    static string MD5() { return "d895b45269767bd90118ccd8955db52c"; }
    NodeInfo()
        : nodeName(""),
          nodeObj(""),
          endpointIp(""),
          endpointPort(0),
          timeOut(0),
          dataDir(""),
          version(""),
          coreFileSize(""),
          openFiles(0)
    {
    }
    void resetDefautlt()
    {
        nodeName = "";
        nodeObj = "";
        endpointIp = "";
        endpointPort = 0;
        timeOut = 0;
        dataDir = "";
        version = "";
        coreFileSize = "";
        openFiles = 0;
    }
    template <typename WriterT>
    void writeTo(tars::TarsOutputStream<WriterT>& _os) const
    {
        _os.write(nodeName, 0);
        _os.write(nodeObj, 1);
        _os.write(endpointIp, 2);
        _os.write(endpointPort, 3);
        _os.write(timeOut, 4);
        _os.write(dataDir, 5);
        if (version != "")
        {
            _os.write(version, 6);
        }
        if (coreFileSize != "")
        {
            _os.write(coreFileSize, 7);
        }
        if (openFiles != 0)
        {
            _os.write(openFiles, 8);
        }
    }
    template <typename ReaderT>
    void readFrom(tars::TarsInputStream<ReaderT>& _is)
    {
        resetDefautlt();
        _is.read(nodeName, 0, true);
        _is.read(nodeObj, 1, true);
        _is.read(endpointIp, 2, true);
        _is.read(endpointPort, 3, true);
        _is.read(timeOut, 4, true);
        _is.read(dataDir, 5, true);
        _is.read(version, 6, false);
        _is.read(coreFileSize, 7, false);
        _is.read(openFiles, 8, false);
    }
    ostream& display(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.display(nodeName, "nodeName");
        _ds.display(nodeObj, "nodeObj");
        _ds.display(endpointIp, "endpointIp");
        _ds.display(endpointPort, "endpointPort");
        _ds.display(timeOut, "timeOut");
        _ds.display(dataDir, "dataDir");
        _ds.display(version, "version");
        _ds.display(coreFileSize, "coreFileSize");
        _ds.display(openFiles, "openFiles");
        return _os;
    }
    ostream& displaySimple(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.displaySimple(nodeName, true);
        _ds.displaySimple(nodeObj, true);
        _ds.displaySimple(endpointIp, true);
        _ds.displaySimple(endpointPort, true);
        _ds.displaySimple(timeOut, true);
        _ds.displaySimple(dataDir, true);
        _ds.displaySimple(version, true);
        _ds.displaySimple(coreFileSize, true);
        _ds.displaySimple(openFiles, false);
        return _os;
    }

public:
    std::string nodeName;
    std::string nodeObj;
    std::string endpointIp;
    tars::Int32 endpointPort;
    tars::Short timeOut;
    std::string dataDir;
    std::string version;
    std::string coreFileSize;
    tars::Int32 openFiles;
};
inline bool operator==(const NodeInfo& l, const NodeInfo& r)
{
    return l.nodeName == r.nodeName && l.nodeObj == r.nodeObj && l.endpointIp == r.endpointIp &&
           l.endpointPort == r.endpointPort && l.timeOut == r.timeOut && l.dataDir == r.dataDir &&
           l.version == r.version && l.coreFileSize == r.coreFileSize && l.openFiles == r.openFiles;
}
inline bool operator!=(const NodeInfo& l, const NodeInfo& r) { return !(l == r); }

struct ServerStateInfo : public tars::TarsStructBase
{
public:
    static string className() { return "tars.ServerStateInfo"; }
    static string MD5() { return "c40a2543579a02b90cb67de80a617a38"; }
    ServerStateInfo()
        : serverState(tars::Inactive),
          processId(0),
          nodeName(""),
          application(""),
          serverName(""),
          settingState(tars::Inactive)
    {
    }
    void resetDefautlt()
    {
        processId = 0;
        nodeName = "";
        application = "";
        serverName = "";
    }
    template <typename WriterT>
    void writeTo(tars::TarsOutputStream<WriterT>& _os) const
    {
        _os.write((tars::Int32)serverState, 0);
        _os.write(processId, 1);
        if (nodeName != "")
        {
            _os.write(nodeName, 2);
        }
        if (application != "")
        {
            _os.write(application, 3);
        }
        if (serverName != "")
        {
            _os.write(serverName, 4);
        }
        _os.write((tars::Int32)settingState, 5);
    }
    template <typename ReaderT>
    void readFrom(tars::TarsInputStream<ReaderT>& _is)
    {
        resetDefautlt();
        tars::Int32 eTemp0 = tars::Inactive;
        _is.read(eTemp0, 0, true);
        serverState = (tars::ServerState)eTemp0;
        _is.read(processId, 1, true);
        _is.read(nodeName, 2, false);
        _is.read(application, 3, false);
        _is.read(serverName, 4, false);
        tars::Int32 eTemp5 = tars::Inactive;
        _is.read(eTemp5, 5, false);
        settingState = (tars::ServerState)eTemp5;
    }
    ostream& display(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.display((tars::Int32)serverState, "serverState");
        _ds.display(processId, "processId");
        _ds.display(nodeName, "nodeName");
        _ds.display(application, "application");
        _ds.display(serverName, "serverName");
        _ds.display((tars::Int32)settingState, "settingState");
        return _os;
    }
    ostream& displaySimple(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.displaySimple((tars::Int32)serverState, true);
        _ds.displaySimple(processId, true);
        _ds.displaySimple(nodeName, true);
        _ds.displaySimple(application, true);
        _ds.displaySimple(serverName, true);
        _ds.displaySimple((tars::Int32)settingState, false);
        return _os;
    }

public:
    tars::ServerState serverState;
    tars::Int32 processId;
    std::string nodeName;
    std::string application;
    std::string serverName;
    tars::ServerState settingState;
};
inline bool operator==(const ServerStateInfo& l, const ServerStateInfo& r)
{
    return l.serverState == r.serverState && l.processId == r.processId &&
           l.nodeName == r.nodeName && l.application == r.application &&
           l.serverName == r.serverName && l.settingState == r.settingState;
}
inline bool operator!=(const ServerStateInfo& l, const ServerStateInfo& r) { return !(l == r); }

struct PatchRequest : public tars::TarsStructBase
{
public:
    static string className() { return "tars.PatchRequest"; }
    static string MD5() { return "b1b7c1f4565fe3a2a3749c726451a6f9"; }
    PatchRequest()
        : appname(""),
          servername(""),
          nodename(""),
          groupname(""),
          binname(""),
          version(""),
          user(""),
          servertype(""),
          patchobj(""),
          md5(""),
          ostype(""),
          filepath("")
    {
    }
    void resetDefautlt()
    {
        appname = "";
        servername = "";
        nodename = "";
        groupname = "";
        binname = "";
        version = "";
        user = "";
        servertype = "";
        patchobj = "";
        md5 = "";
        ostype = "";
        filepath = "";
    }
    template <typename WriterT>
    void writeTo(tars::TarsOutputStream<WriterT>& _os) const
    {
        _os.write(appname, 0);
        _os.write(servername, 1);
        _os.write(nodename, 2);
        _os.write(groupname, 3);
        _os.write(binname, 4);
        _os.write(version, 5);
        _os.write(user, 6);
        _os.write(servertype, 7);
        _os.write(patchobj, 8);
        _os.write(md5, 9);
        if (ostype != "")
        {
            _os.write(ostype, 10);
        }
        if (filepath != "")
        {
            _os.write(filepath, 11);
        }
    }
    template <typename ReaderT>
    void readFrom(tars::TarsInputStream<ReaderT>& _is)
    {
        resetDefautlt();
        _is.read(appname, 0, true);
        _is.read(servername, 1, true);
        _is.read(nodename, 2, true);
        _is.read(groupname, 3, true);
        _is.read(binname, 4, true);
        _is.read(version, 5, true);
        _is.read(user, 6, true);
        _is.read(servertype, 7, true);
        _is.read(patchobj, 8, true);
        _is.read(md5, 9, true);
        _is.read(ostype, 10, false);
        _is.read(filepath, 11, false);
    }
    ostream& display(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.display(appname, "appname");
        _ds.display(servername, "servername");
        _ds.display(nodename, "nodename");
        _ds.display(groupname, "groupname");
        _ds.display(binname, "binname");
        _ds.display(version, "version");
        _ds.display(user, "user");
        _ds.display(servertype, "servertype");
        _ds.display(patchobj, "patchobj");
        _ds.display(md5, "md5");
        _ds.display(ostype, "ostype");
        _ds.display(filepath, "filepath");
        return _os;
    }
    ostream& displaySimple(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.displaySimple(appname, true);
        _ds.displaySimple(servername, true);
        _ds.displaySimple(nodename, true);
        _ds.displaySimple(groupname, true);
        _ds.displaySimple(binname, true);
        _ds.displaySimple(version, true);
        _ds.displaySimple(user, true);
        _ds.displaySimple(servertype, true);
        _ds.displaySimple(patchobj, true);
        _ds.displaySimple(md5, true);
        _ds.displaySimple(ostype, true);
        _ds.displaySimple(filepath, false);
        return _os;
    }

public:
    std::string appname;
    std::string servername;
    std::string nodename;
    std::string groupname;
    std::string binname;
    std::string version;
    std::string user;
    std::string servertype;
    std::string patchobj;
    std::string md5;
    std::string ostype;
    std::string filepath;
};
inline bool operator==(const PatchRequest& l, const PatchRequest& r)
{
    return l.appname == r.appname && l.servername == r.servername && l.nodename == r.nodename &&
           l.groupname == r.groupname && l.binname == r.binname && l.version == r.version &&
           l.user == r.user && l.servertype == r.servertype && l.patchobj == r.patchobj &&
           l.md5 == r.md5 && l.ostype == r.ostype && l.filepath == r.filepath;
}
inline bool operator!=(const PatchRequest& l, const PatchRequest& r) { return !(l == r); }

struct PreparePatchRequest : public tars::TarsStructBase
{
public:
    static string className() { return "tars.PreparePatchRequest"; }
    static string MD5() { return "fe70f8db87044a1fecbaa5f4822c8734"; }
    PreparePatchRequest()
        : appname(""),
          servername(""),
          groupname(""),
          version(""),
          user(""),
          servertype(""),
          patchobj(""),
          md5(""),
          ostype(""),
          filepath("")
    {
    }
    void resetDefautlt()
    {
        appname = "";
        servername = "";
        groupname = "";
        version = "";
        user = "";
        servertype = "";
        patchobj = "";
        md5 = "";
        ostype = "";
        filepath = "";
    }
    template <typename WriterT>
    void writeTo(tars::TarsOutputStream<WriterT>& _os) const
    {
        _os.write(appname, 0);
        _os.write(servername, 1);
        _os.write(groupname, 2);
        _os.write(version, 3);
        _os.write(user, 4);
        _os.write(servertype, 5);
        _os.write(patchobj, 6);
        _os.write(md5, 7);
        _os.write(ostype, 8);
        _os.write(specialNodeList, 9);
        if (filepath != "")
        {
            _os.write(filepath, 10);
        }
    }
    template <typename ReaderT>
    void readFrom(tars::TarsInputStream<ReaderT>& _is)
    {
        resetDefautlt();
        _is.read(appname, 0, true);
        _is.read(servername, 1, true);
        _is.read(groupname, 2, true);
        _is.read(version, 3, true);
        _is.read(user, 4, true);
        _is.read(servertype, 5, true);
        _is.read(patchobj, 6, true);
        _is.read(md5, 7, true);
        _is.read(ostype, 8, true);
        _is.read(specialNodeList, 9, true);
        _is.read(filepath, 10, false);
    }
    ostream& display(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.display(appname, "appname");
        _ds.display(servername, "servername");
        _ds.display(groupname, "groupname");
        _ds.display(version, "version");
        _ds.display(user, "user");
        _ds.display(servertype, "servertype");
        _ds.display(patchobj, "patchobj");
        _ds.display(md5, "md5");
        _ds.display(ostype, "ostype");
        _ds.display(specialNodeList, "specialNodeList");
        _ds.display(filepath, "filepath");
        return _os;
    }
    ostream& displaySimple(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.displaySimple(appname, true);
        _ds.displaySimple(servername, true);
        _ds.displaySimple(groupname, true);
        _ds.displaySimple(version, true);
        _ds.displaySimple(user, true);
        _ds.displaySimple(servertype, true);
        _ds.displaySimple(patchobj, true);
        _ds.displaySimple(md5, true);
        _ds.displaySimple(ostype, true);
        _ds.displaySimple(specialNodeList, true);
        _ds.displaySimple(filepath, false);
        return _os;
    }

public:
    std::string appname;
    std::string servername;
    std::string groupname;
    std::string version;
    std::string user;
    std::string servertype;
    std::string patchobj;
    std::string md5;
    std::string ostype;
    vector<std::string> specialNodeList;
    std::string filepath;
};
inline bool operator==(const PreparePatchRequest& l, const PreparePatchRequest& r)
{
    return l.appname == r.appname && l.servername == r.servername && l.groupname == r.groupname &&
           l.version == r.version && l.user == r.user && l.servertype == r.servertype &&
           l.patchobj == r.patchobj && l.md5 == r.md5 && l.ostype == r.ostype &&
           l.specialNodeList == r.specialNodeList && l.filepath == r.filepath;
}
inline bool operator!=(const PreparePatchRequest& l, const PreparePatchRequest& r)
{
    return !(l == r);
}
inline bool operator<(const PreparePatchRequest& l, const PreparePatchRequest& r)
{
    if (l.appname != r.appname) return (l.appname < r.appname);
    if (l.servername != r.servername) return (l.servername < r.servername);
    if (l.version != r.version) return (l.version < r.version);
    return false;
}
inline bool operator<=(const PreparePatchRequest& l, const PreparePatchRequest& r)
{
    return !(r < l);
}
inline bool operator>(const PreparePatchRequest& l, const PreparePatchRequest& r) { return r < l; }
inline bool operator>=(const PreparePatchRequest& l, const PreparePatchRequest& r)
{
    return !(l < r);
}

}  // namespace tars

#endif
